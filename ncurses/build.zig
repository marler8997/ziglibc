const std = @import("std");
const GitRepoStep = @import("../GitRepoStep.zig");
const ProcessFileStep = @import("../ProcessFileStep.zig");
const filecheck = @import("../filecheck.zig");

const NcursesPrepStep = struct {
    step: std.build.Step,
    builder: *std.build.Builder,
    repo_path: []const u8,

    defs_h_src: []const u8,
    defs_h_dst: []const u8,
    //curses_h: []const u8,

    pub fn create(b: *std.build.Builder, repo: *GitRepoStep) *NcursesPrepStep {
        var result = b.allocator.create(NcursesPrepStep) catch unreachable;
        result.* = NcursesPrepStep{
            .step = std.build.Step.init(.{
                .id = .custom,
                .name = "ncurses prep",
                .owner = b,
                .makeFn = make,
            }),
            .builder = b,
            .repo_path = repo.path,
            .defs_h_src = b.pathJoin(&.{ repo.path, "include", "ncurses_defs" }),
            .defs_h_dst = b.pathJoin(&.{ repo.path, "include", "ncurses_def.h" }),
            //.curses_h = b.pathJoin(&.{repo.path, "include", "curses.h"}),
        };
        result.*.step.dependOn(&repo.step);
        return result;
    }
    fn make(step: *std.build.Step, progress: *std.Progress.Node) !void {
        _ = progress;
        const self = @fieldParentPtr(NcursesPrepStep, "step", step);
        //try self.generateCuresesH();
        try self.generateNcursesDefH();
    }

    //fn generateCursesH(self: NcursesPrepStep) !void {
    //}

    fn generateNcursesDefH(self: NcursesPrepStep) !void {
        // TODO: use bash on include/MKncurses_def.sh
        //       they use awk, I don't think there's any reason we
        //       couldn't use awk as well.  We should be able to get awk
        //       working on any platform/OS.
        if (try filecheck.leftFileIsNewer(self.defs_h_dst, self.defs_h_src))
            return;
        var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
        defer arena.deinit();
        const content = std.fs.cwd().readFileAlloc(arena.allocator(), self.defs_h_src, std.math.maxInt(usize)) catch |err| {
            std.log.err("failed to read file '{s}' to process ({s})", .{ self.defs_h_src, @errorName(err) });
            std.os.exit(0xff);
        };

        const tmp_filename = try std.fmt.allocPrint(arena.allocator(), "{s}.processing", .{self.defs_h_dst});
        {
            var out_file = try std.fs.cwd().createFile(tmp_filename, .{});
            defer out_file.close();

            const writer = out_file.writer();
            try writer.writeAll("/* This file is generated by ncurses/build.zig */\n");
            try writer.writeAll("#ifndef NC_DEFINE_H\n");
            try writer.writeAll("#define NC_DEFINE_H\n");

            var it = std.mem.split(u8, content, "\n");
            while (it.next()) |line_untrimmed| {
                const line = std.mem.trim(u8, line_untrimmed, " \t\r");
                if (line.len == 0 or line[0] == '#') continue;
                var field_it = std.mem.tokenize(u8, line, " \t");
                const name = field_it.next().?;
                const optional_value = field_it.next();
                try writer.print("\n#ifndef {s}\n", .{name});
                if (optional_value) |value| {
                    const value_offset = @intFromPtr(value.ptr) - @intFromPtr(line.ptr);
                    try writer.print("#define {s} {s}\n", .{ name, line[value_offset..] });
                } else {
                    try writer.print("#define {s} 0\n", .{name});
                }
                try writer.print("#endif\n", .{});
            }
            try writer.writeAll("#endif /* NC_DEFINE_H */\n");
        }
        try std.fs.cwd().rename(tmp_filename, self.defs_h_dst);
    }
};

fn addProcessFile(
    b: *std.build.Builder,
    repo: *GitRepoStep,
    exe: *std.build.LibExeObjStep,
    in_sub_path: []const u8,
    out_sub_path: []const u8,
    opt: struct {
        subs: []const ProcessFileStep.Sub = &[_]ProcessFileStep.Sub{},
    },
) void {
    const process_file = ProcessFileStep.create(b, .{
        .in_filename = b.pathJoin(&.{ repo.path, in_sub_path }),
        .out_filename = b.pathJoin(&.{ repo.path, out_sub_path }),
        .subs = opt.subs,
    });
    process_file.step.dependOn(&repo.step);
    exe.step.dependOn(&process_file.step);
}

pub fn add(
    b: *std.build.Builder,
    target: anytype,
    optimize: anytype,
    libc_only_std_static: *std.build.LibExeObjStep,
    zig_posix: *std.build.LibExeObjStep,
) *std.build.LibExeObjStep {
    const repo = GitRepoStep.create(b, .{
        .url = "https://github.com/mirror/ncurses",
        .sha = "deb0d07e8eb4803b9e9653359eab17a30d04369d",
        .branch = null,
    });

    const prep = NcursesPrepStep.create(b, repo);

    const exe = b.addStaticLibrary(.{
        .name = "ncurses",
        .target = target,
        .optimize = optimize,
    });
    addProcessFile(
        b,
        repo,
        exe,
        b.pathJoin(&.{ "include", "ncurses_dll.h.in" }),
        b.pathJoin(&.{ "include", "ncurses_dll.h" }),
        .{},
    );

    const defs_sub = ProcessFileStep.Sub{
        .current = "@DEFS@",
        .new = @embedFile("DEFS"),
    };
    addProcessFile(
        b,
        repo,
        exe,
        b.pathJoin(&.{ "include", "ncurses_cfg.hin" }),
        b.pathJoin(&.{ "include", "ncurses_cfg.h" }),
        .{ .subs = &.{defs_sub} },
    );
    //addProcessFile(b, repo, exe,
    //    b.pathJoin(&.{"include", "curses.h.in"}),
    //    b.pathJoin(&.{"include", "curses.head"}),
    //   .{ .subs = &.{ defs_sub } },
    //);
    const install = b.addInstallArtifact(exe, .{});
    exe.step.dependOn(&prep.step);
    const repo_path = repo.getPath(&exe.step);
    var files = std.ArrayList([]const u8).init(b.allocator);
    for ([_][]const u8{"lib_initscr.c"}) |src| {
        files.append(b.pathJoin(&.{ repo_path, "ncurses", "base", src })) catch unreachable;
    }
    exe.addCSourceFiles(files.toOwnedSlice() catch unreachable, &[_][]const u8{
        "-std=c99",
    });
    exe.addIncludePath(.{ .path = b.pathJoin(&.{ repo_path, "include" }) });
    exe.addIncludePath(.{ .path = b.pathJoin(&.{ repo_path, "ncurses" }) });

    exe.addIncludePath(.{ .path = "inc/libc" });
    exe.addIncludePath(.{ .path = "inc/posix" });
    exe.addIncludePath(.{ .path = "inc/linux" });
    //exe.addIncludePath(.{.path="inc/gnu"});
    exe.linkLibrary(libc_only_std_static);
    //exe.linkLibrary(zig_start);
    exe.linkLibrary(zig_posix);
    //exe.linkLibrary(zig_gnu);
    // TODO: should libc_only_std_static and zig_start be able to add library dependencies?
    if (target.getOs().tag == .windows) {
        exe.linkSystemLibrary("ntdll");
        exe.linkSystemLibrary("kernel32");
    }

    const step = b.step("ncurses", "build the ncurses library");
    step.dependOn(&install.step);

    return exe;
}
